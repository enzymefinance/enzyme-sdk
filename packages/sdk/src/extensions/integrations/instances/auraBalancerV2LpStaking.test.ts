import { AURA, AURA_BALANCER_V2_LP_STAKING_ADAPTER, INTEGRATION_MANAGER } from "../../../../tests/constants.js";
import { sendTestTransaction, testActions, testClientMainnet } from "../../../../tests/globals.js";

import { Integration } from "../integrationTypes.js";
import { prepareUseIntegration } from "../prepareUseIntegration.js";
import {
  decodeBalancerV2LiquidityClaimRewardsArgs,
  decodeBalancerV2LiquidityLendAndStakeArgsAndUnstakeAndRedeemArgs,
} from "./balancerV2Liquidity.js";
import { type Address, parseEther } from "viem";
import { expect, test } from "vitest";

const vaultProxy = "0x278C647F7cfb9D55580c69d3676938608C945ba8" as const;
const comptrollerProxy = "0x746de9838BB3D14f1aC1b78Bd855E48201F221a6" as const;
const vaultOwner = "0x0D947D68f583e8B23ff816df9ff3f23a8Cfd7496" as const;

test("prepare adapter trade for Aura Balancer V2 Lp Staking lend and stake should work correctly", async () => {
  await testClientMainnet.reset({
    blockNumber: 16875310n,
  });

  await testClientMainnet.setBalance({ address: vaultOwner, value: parseEther("1") });

  // Taken from tx 0x9e566d1b57693cba3ae93a41e85860698b6bc90a7ede9a3c246912afb24f6229
  const integrationData =
    "0x000000000000000000000000095d3f1bb143a626867e0dfc97968ed561311cb21e19cf2d73a72ef1332c882f20534b6519be0276000200000000000000000112000000000000000000000000000000000000000000000000000a5bca86d978e000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000aa87bee538000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000ae78736cd615f374d3085123a210448e74fc6393000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee53800000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000a5bca86d978e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee538000";

  const decodedIntegrationData = decodeBalancerV2LiquidityLendAndStakeArgsAndUnstakeAndRedeemArgs(integrationData);

  await sendTestTransaction({
    network: "mainnet",
    ...prepareUseIntegration({
      integrationManager: INTEGRATION_MANAGER,
      integrationAdapter: AURA_BALANCER_V2_LP_STAKING_ADAPTER,
      callArgs: {
        type: Integration.AuraBalancerV2LpStakingLendAndStake,
        ...decodedIntegrationData,
      },
    }),
    account: vaultOwner,
    address: comptrollerProxy,
  });

  await testActions.assertBalanceOf({
    token: decodedIntegrationData.stakingToken,
    account: vaultProxy,
    expected: 5861952002703072n,
  });
});

test("prepare adapter trade for Aura Balancer V2 Lp Staking unstake and redeem should work correctly", async () => {
  await testClientMainnet.reset({
    blockNumber: 16882441n,
  });

  await testClientMainnet.setBalance({ address: vaultOwner, value: parseEther("1") });

  // Taken from tx 0x6ddf3d5f7862e18ae42b09403f6fcd6ca22d2a2f5674a97db5ca572551538c7a
  const integrationData =
    "0x000000000000000000000000095d3f1bb143a626867e0dfc97968ed561311cb21e19cf2d73a72ef1332c882f20534b6519be02760002000000000000000001120000000000000000000000000000000000000000000000000001c6bf5263400000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001af46007e08cb000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000ae78736cd615f374d3085123a210448e74fc6393000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001af46007e08cb000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c6bf526340000000000000000000000000000000000000000000000000000000000000000001";

  const decodedIntegrationData = decodeBalancerV2LiquidityLendAndStakeArgsAndUnstakeAndRedeemArgs(integrationData);

  await sendTestTransaction({
    network: "mainnet",
    ...prepareUseIntegration({
      integrationManager: INTEGRATION_MANAGER,
      integrationAdapter: AURA_BALANCER_V2_LP_STAKING_ADAPTER,
      callArgs: {
        type: Integration.AuraBalancerV2LpStakingUnstakeAndRedeem,
        ...decodedIntegrationData,
      },
    }),
    account: vaultOwner,
    address: comptrollerProxy,
  });

  await testActions.assertBalanceOf({
    token: decodedIntegrationData.usedTokens[0] as Address,
    account: vaultProxy,
    expected: 2107497139335540265n,
  });
});

test("prepare adapter trade for Aura Balancer V2 Lp Staking claim rewards should work correctly", async () => {
  await testClientMainnet.reset({
    blockNumber: 16875832n,
  });

  await testClientMainnet.setBalance({ address: vaultOwner, value: parseEther("1") });

  // Taken from tx 0x6ed869d7b67de0806eb14ab7621d5e58c519fd709813b28179304b3b283ea47b
  const integrationData = "0x000000000000000000000000095d3f1bb143a626867e0dfc97968ed561311cb2";

  const decodedIntegrationData = decodeBalancerV2LiquidityClaimRewardsArgs(integrationData);

  const auraBalanceBeforeClaim = await testActions.getBalanceOf({
    token: AURA,
    account: vaultProxy,
  });

  await sendTestTransaction({
    network: "mainnet",
    ...prepareUseIntegration({
      integrationManager: INTEGRATION_MANAGER,
      integrationAdapter: AURA_BALANCER_V2_LP_STAKING_ADAPTER,
      callArgs: {
        type: Integration.AuraBalancerV2LpStakingClaimRewards,
        ...decodedIntegrationData,
      },
    }),
    account: vaultOwner,
    address: comptrollerProxy,
  });

  const auraBalanceAfterClaim = await testActions.getBalanceOf({
    token: AURA,
    account: vaultProxy,
  });

  expect(auraBalanceAfterClaim).toBeGreaterThan(auraBalanceBeforeClaim);
});
